<!DOCTYPE html>
<html lang="en">
<head>
<script type="module">

    function instantiate(bytes, imports) {
        return WebAssembly.compile(bytes).then(m => new WebAssembly.Instance(m, imports));
    }

    function translateColor(input) {
        switch(input) {
            case 0:
                return [0,0,0,255];
                break;
            case 1:
                return [255,0,0,255];
                break;
            case 2:
                return [0,255,0,255];
                break;
            case 3:
                return [0,0,255,255];
                break;
            default: 
                return [0,0,0,0];
        }
    }

    // Set up the canvas with a 2D rendering context
    const canvas = document.getElementById("canvas");
    const boundingRect = canvas.getBoundingClientRect();
    const ctx = canvas.getContext("2d");

    // Compute the size of the viewport
    const ratio  = window.devicePixelRatio || 1;
    const width  = (boundingRect.width  | 0) * ratio;
    const height = (boundingRect.height | 0) * ratio;
    const size = width * height;

    canvas.width  = width;
    canvas.height = height;
    ctx.scale(ratio, ratio);

    let max_color_atoms = 100;
    let color_count = 3; // red, green, blue
    let u16_values_per_atom = 5; // x,y,v_x,v_y,color
    let bytes_for_u16 = 2; // fixed u16 needs 2 bytes
    let page_size = 64000; // fixed by assemblyscript (64kb)

    const importObject = {
        env: {
            seed() {
                // ~lib/builtins/seed() => f64
                return (() => {
                // @external.js
                return Date.now() * Math.random();
                })();
            }
        }
    }

    const exports = await fetch('./build/release.wasm').then(response => response.arrayBuffer())
    .then(bytes => instantiate(bytes, importObject))
    .then(instance => instance.exports);

    // Initialize memory
    const bytes_for_objects = Math.ceil((max_color_atoms * color_count * u16_values_per_atom * bytes_for_u16))
    const bytes_for_image_buffer = width*height*bytes_for_u16;

    exports.memory.grow((bytes_for_objects + bytes_for_image_buffer) / page_size);
    const u16array = new Uint16Array(exports.memory.buffer);

    // Initialize image data buffer
    console.log("Imagedata width: " + width + " height " + height)
    const imageData = ctx.createImageData(width, height);
    // const colors = computeColors();

    exports.random_create(0, max_color_atoms, u16_values_per_atom, width, height);
    exports.random_create(1, max_color_atoms, u16_values_per_atom, width, height);
    exports.random_create(2, max_color_atoms, u16_values_per_atom, width, height);
    exports.update(max_color_atoms, u16_values_per_atom, width, height);

    // Translate colors
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const [r,g,b,a] = translateColor(u16array[bytes_for_objects/bytes_for_u16 + y * width + x]);
            imageData.data[width*y*4 + x*4 + 0] = r;
            imageData.data[width*y*4 + x*4 + 1] = g;
            imageData.data[width*y*4 + x*4 + 2] = b;
            imageData.data[width*y*4 + x*4 + 3] = a;
        }
    }

    // Render the image buffer.
    console.log(imageData)
    ctx.putImageData(imageData, 0, 0);

    function computeColors() {
        const canvas = document.createElement("canvas");
        canvas.width = 2048;
        canvas.height = 1;
        const ctx = canvas.getContext("2d");
        const grd = ctx.createLinearGradient(0, 0, 3, 0);
        grd.addColorStop(0.00, "#000764");
        grd.addColorStop(0.16, "#2068CB");
        grd.addColorStop(0.42, "#EDFFFF");
        grd.addColorStop(0.6425, "#FFAA00");
        grd.addColorStop(0.8575, "#000200");
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, 2048, 1);
        return new Uint32Array(ctx.getImageData(0, 0, 2048, 1).data.buffer);
    }
</script>
</head>
<body>
    <canvas id="canvas" width="500" height="500"></canvas>
</body>
</html>
