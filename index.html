<!DOCTYPE html>
<html lang="en">
<head>
<script type="module">

    function instantiate(bytes, imports) {
        return WebAssembly.compile(bytes).then(m => new WebAssembly.Instance(m, imports));
    }

    function translateColor(input) {
        switch(input) {
            case 0:
                return [0,0,0,255];
                break;
            case 1:
                return [255,0,0,255];
                break;
            case 2:
                return [0,255,0,255];
                break;
            case 3:
                return [0,0,255,255];
                break;
            default: 
                return [0,0,0,0];
        }
    }

    function render_atom(imageData, width, atom_offset) {
        const atom_x = u16array[atom_offset + 0];
        const atom_y = u16array[atom_offset + 1];
        const atom_color = u16array[atom_offset + 4];
        const [r,g,b,a] = translateColor(atom_color);
        imageData.data[width*atom_y*4 + atom_x*4 + 0] = r;
        imageData.data[width*atom_y*4 + atom_x*4 + 1] = g;
        imageData.data[width*atom_y*4 + atom_x*4 + 2] = b;
        imageData.data[width*atom_y*4 + atom_x*4 + 3] = a;
    }

    // Set up the canvas with a 2D rendering context
    const canvas = document.getElementById("canvas");
    const boundingRect = canvas.getBoundingClientRect();
    const ctx = canvas.getContext("2d");

    // Compute the size of the viewport
    const ratio  = window.devicePixelRatio || 1;
    const width  = (boundingRect.width  | 0) * ratio;
    const height = (boundingRect.height | 0) * ratio;
    const size = width * height;

    canvas.width  = width;
    canvas.height = height;
    ctx.scale(ratio, ratio);

    let max_color_atoms = 100;
    let color_count = 3; // red, green, blue
    let u16_values_per_atom = 5; // x,y,v_x,v_y,color
    let bytes_for_u16 = 2; // fixed u16 needs 2 bytes
    let page_size = 64000; // fixed by assemblyscript (64kb)

    const importObject = {
        env: {
            seed() {
                // ~lib/builtins/seed() => f64
                return (() => {
                // @external.js
                return Date.now() * Math.random();
                })();
            }
        }
    }

    const exports = await fetch('./build/release.wasm').then(response => response.arrayBuffer())
    .then(bytes => instantiate(bytes, importObject))
    .then(instance => instance.exports);

    // Initialize memory
    const bytes_for_objects = Math.ceil((max_color_atoms * color_count * u16_values_per_atom * bytes_for_u16))
    const bytes_for_image_buffer = width*height*bytes_for_u16;
    exports.memory.grow((bytes_for_objects + bytes_for_image_buffer) / page_size);
    const u16array = new Uint16Array(exports.memory.buffer);

    // Spawn random atoms
    exports.random_create(0, max_color_atoms, u16_values_per_atom, width, height);
    exports.random_create(1, max_color_atoms, u16_values_per_atom, width, height);
    exports.random_create(2, max_color_atoms, u16_values_per_atom, width, height);

    console.time("Ticktotal")
    console.time("Logictick")

    exports.update(max_color_atoms, u16_values_per_atom, width, height);

    console.timeEnd("Logictick")
    console.time("Rendertick")

    // Initialize image data buffer
    const imageData = ctx.createImageData(width, height);

    // Background
    for(let i = 0; i < imageData.data.length; i += 4) {
        imageData.data[i+0] = 0;
        imageData.data[i+1] = 0;
        imageData.data[i+2] = 0;
        imageData.data[i+3] = 255;
    }

    // Render atoms
    const color0_offset = 0;
    const color1_offset = max_color_atoms * 1 * u16_values_per_atom;
    const color2_offset = max_color_atoms * 2 * u16_values_per_atom;
    for(let i = 0; i < max_color_atoms; i++) {
        render_atom(imageData, width, color0_offset + i * u16_values_per_atom);
    }
    for(let i = 0; i < max_color_atoms; i++) {
        render_atom(imageData, width, color1_offset + i * u16_values_per_atom);
    }
    for(let i = 0; i < max_color_atoms; i++) {
        render_atom(imageData, width, color2_offset + i * u16_values_per_atom);
    }

    // Paint rendered image
    ctx.putImageData(imageData, 0, 0);

    console.timeEnd("Rendertick")
    console.timeEnd("Ticktotal")
</script>
</head>
<body>
    <canvas id="canvas" width="500" height="500"></canvas>
</body>
</html>
